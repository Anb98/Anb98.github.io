(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{265:function(e,n){e.exports={body:'## Qu√© es un closure en JS?\nEmpecemos por definir que es un closure (algunos los llaman como clausura o cerradura yo prefiero llamarle closure üòÖ). En pocas palabas un closure es:\n> Un closure es una funci√≥n que est√° dentro de otra funci√≥n.\n\nSimple y al grano, es una funci√≥n dentro de otra. Ahora bien, ¬øpara qu√© nos puede servir hacer un closure en nuestro c√≥digo? La principal ventaja es que nos permite tener variables en la funci√≥n padre que solo ser√°n accesibles desde la funci√≥n interna (hija), adem√°s de poder acceder tambi√©n a los parametros de la funci√≥n padre. Esto nos permite tener un **estado privado** dentro de nuestra funci√≥n pero m√°s interesante a√∫n que este sea ***un estado reusable***.\n\nUna parte importante de los closures es que deben ser retornados por la funci√≥n padre hacia el exterior, a esto se le conoce como funci√≥n de alto nivel o en ingl√©s *High Order Functions*, te invito investigar m√°s sobre ello.\n\nRegresando a los closures un ejemplo sencillo ser√≠a:\n\n```js\nconst contador = () => {   //funcion padre\n    let valor = 0;      //estado privado y reusable\n\n    return ()=>{        //closure o funcion hija\n        return valor++;\n    }\n}\n```\n\nAhora para utilizar nuestro closure:\n\n```js\nconst contar = contador();  //guardamos el closure en la constante contar\n\nconsole.log(contar())   //0\nconsole.log(contar())   //1\nconsole.log(contar())   //2\n```\n\nCada vez que llamamos *contar()* accedemos al closure, se retorna su valor actual y luego suma 1 a la variable *valor*.\n\n### Pruebalo\n<p class="codepen" data-height="265" data-theme-id="dark" data-default-tab="js,result" data-user="anb98" data-slug-hash="bGbXgJG" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="Closure">\n  <span>See the Pen <a href="https://codepen.io/anb98/pen/bGbXgJG">\n  Closure</a> by Abdiel Martinez (<a href="https://codepen.io/anb98">@anb98</a>)\n  on <a href="https://codepen.io">CodePen</a>.</span>\n</p>\n<script async src="https://static.codepen.io/assets/embed/ei.js"><\/script>\n\n## A la pr√°ctica\nAunque desde que aprend√≠ este concepto me pareci√≥ muy interesante, a√∫n no hab√≠a conseguido encontrar un caso pr√°ctico, finalmente encontr√© uno que podr√≠a serle util a m√°s de alguno.\n\nEl problema consiste en realizar consultas a una api, en mi caso realtime de firebase, donde cada resultado quede disponible para que en la siguiente vez que se solicite el mismo dato en lugar de volver a llamar a la *api*, el resultado se devuelva desde el estado local, reduciendo as√≠ el tiempo de respuesta.\n\nMi soluci√≥n:\n\n```js\nimport firebase from \'firebase\';\n\nconst buscarNodo = (nodo) => {\n    const data = {};    //estado reusable\n\n    return async (valor) => {   //closure asincrono\n        if (valor) {\n\n            const res = data[valor];\n            if (res)    \n                return res;  //si existe en el estado local se retorna\n\n            else {\n                const snap = await firebase\n                .database()\n                .ref()\n                .child(nodo)\n                .child(valor)\n                .once(\'value\');\n\n                if (snap.exists()) {\n                    const result = snap.val();\n                    result.key   = valor;\n                    data[valor]  = result;  //se argega al estado local\n\n                    return result;  \n                }\n            }\n        }\n        \n        return false;   //si no existe valor de busqueda \n        //o si no hay resultados en el estado local ni en la api\n    }\n}\n\nexport default buscarNodo;\n```\n¬øQu√© le mejorar√≠as?ü§î\n\nPara utilizarlo podr√≠a  ser:\n```js\nconst buscarAlumno   = buscarNodo(\'alumnos\');\nconst buscarMateria  = buscarNodo(\'materias\');\nconst buscarProfesor = buscarNodo(\'profesores\');\n\n(async ()=>{  \n    // esto es conocido como funcion invocada \n    // inmediatamente, en ingles: \n    // Immediately invoked function expression (IIFE)\n\n\n    const alumnoEncontrado   = await buscarAlumno( \'idAlumno\');\n    const materiaEncontrada  = await buscarMateria( \'idMateria\' );\n    const profesorEncontrado = await buscarProfesor( \'idProfesor\' );\n\n})();\n```\n\nEste es mi caso particular, la llamada a firebase podr√≠a ser sustituida por cualquier otra api.\n\n¬øQu√© otra idea se te ocurre para utilizar closures?\nComp√°rtelo en los comentarios üòä',html:'<h2>Qu√© es un closure en JS?</h2>\n<p>Empecemos por definir que es un closure (algunos los llaman como clausura o cerradura yo prefiero llamarle closure üòÖ). En pocas palabas un closure es:</p>\n<blockquote>\n<p>Un closure es una funci√≥n que est√° dentro de otra funci√≥n.</p>\n</blockquote>\n<p>Simple y al grano, es una funci√≥n dentro de otra. Ahora bien, ¬øpara qu√© nos puede servir hacer un closure en nuestro c√≥digo? La principal ventaja es que nos permite tener variables en la funci√≥n padre que solo ser√°n accesibles desde la funci√≥n interna (hija), adem√°s de poder acceder tambi√©n a los parametros de la funci√≥n padre. Esto nos permite tener un <strong>estado privado</strong> dentro de nuestra funci√≥n pero m√°s interesante a√∫n que este sea <em><strong>un estado reusable</strong></em>.</p>\n<p>Una parte importante de los closures es que deben ser retornados por la funci√≥n padre hacia el exterior, a esto se le conoce como funci√≥n de alto nivel o en ingl√©s <em>High Order Functions</em>, te invito investigar m√°s sobre ello.</p>\n<p>Regresando a los closures un ejemplo sencillo ser√≠a:</p>\n<pre><code class="language-js">const contador = () =&gt; {   //funcion padre\n    let valor = 0;      //estado privado y reusable\n\n    return ()=&gt;{        //closure o funcion hija\n        return valor++;\n    }\n}\n</code></pre>\n<p>Ahora para utilizar nuestro closure:</p>\n<pre><code class="language-js">const contar = contador();  //guardamos el closure en la constante contar\n\nconsole.log(contar())   //0\nconsole.log(contar())   //1\nconsole.log(contar())   //2\n</code></pre>\n<p>Cada vez que llamamos <em>contar()</em> accedemos al closure, se retorna su valor actual y luego suma 1 a la variable <em>valor</em>.</p>\n<h3>Pruebalo</h3>\n<p class="codepen" data-height="265" data-theme-id="dark" data-default-tab="js,result" data-user="anb98" data-slug-hash="bGbXgJG" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="Closure">\n  <span>See the Pen <a href="https://codepen.io/anb98/pen/bGbXgJG">\n  Closure</a> by Abdiel Martinez (<a href="https://codepen.io/anb98">@anb98</a>)\n  on <a href="https://codepen.io">CodePen</a>.</span>\n</p>\n<script async src="https://static.codepen.io/assets/embed/ei.js"><\/script>\n<h2>A la pr√°ctica</h2>\n<p>Aunque desde que aprend√≠ este concepto me pareci√≥ muy interesante, a√∫n no hab√≠a conseguido encontrar un caso pr√°ctico, finalmente encontr√© uno que podr√≠a serle util a m√°s de alguno.</p>\n<p>El problema consiste en realizar consultas a una api, en mi caso realtime de firebase, donde cada resultado quede disponible para que en la siguiente vez que se solicite el mismo dato en lugar de volver a llamar a la <em>api</em>, el resultado se devuelva desde el estado local, reduciendo as√≠ el tiempo de respuesta.</p>\n<p>Mi soluci√≥n:</p>\n<pre><code class="language-js">import firebase from \'firebase\';\n\nconst buscarNodo = (nodo) =&gt; {\n    const data = {};    //estado reusable\n\n    return async (valor) =&gt; {   //closure asincrono\n        if (valor) {\n\n            const res = data[valor];\n            if (res)    \n                return res;  //si existe en el estado local se retorna\n\n            else {\n                const snap = await firebase\n                .database()\n                .ref()\n                .child(nodo)\n                .child(valor)\n                .once(\'value\');\n\n                if (snap.exists()) {\n                    const result = snap.val();\n                    result.key   = valor;\n                    data[valor]  = result;  //se argega al estado local\n\n                    return result;  \n                }\n            }\n        }\n        \n        return false;   //si no existe valor de busqueda \n        //o si no hay resultados en el estado local ni en la api\n    }\n}\n\nexport default buscarNodo;\n</code></pre>\n<p>¬øQu√© le mejorar√≠as?ü§î</p>\n<p>Para utilizarlo podr√≠a  ser:</p>\n<pre><code class="language-js">const buscarAlumno   = buscarNodo(\'alumnos\');\nconst buscarMateria  = buscarNodo(\'materias\');\nconst buscarProfesor = buscarNodo(\'profesores\');\n\n(async ()=&gt;{  \n    // esto es conocido como funcion invocada \n    // inmediatamente, en ingles: \n    // Immediately invoked function expression (IIFE)\n\n\n    const alumnoEncontrado   = await buscarAlumno( \'idAlumno\');\n    const materiaEncontrada  = await buscarMateria( \'idMateria\' );\n    const profesorEncontrado = await buscarProfesor( \'idProfesor\' );\n\n})();\n</code></pre>\n<p>Este es mi caso particular, la llamada a firebase podr√≠a ser sustituida por cualquier otra api.</p>\n<p>¬øQu√© otra idea se te ocurre para utilizar closures?\nComp√°rtelo en los comentarios üòä</p>\n',attributes:{_meta:{resourcePath:"C:\\Users\\rocke\\Documents\\Projects\\blog\\assets\\articulos\\Ejemplo-practico-de-Closure.md"}},vue:{render:"return function render() { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _vm._m(0) }",staticRenderFns:'return [function () { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'div\',{staticClass:"frontmatter-markdown"},[_c(\'h2\',[_vm._v("Qu√© es un closure en JS?")]),_vm._v(" "),_c(\'p\',[_vm._v("Empecemos por definir que es un closure (algunos los llaman como clausura o cerradura yo prefiero llamarle closure üòÖ). En pocas palabas un closure es:")]),_vm._v(" "),_c(\'blockquote\',[_c(\'p\',[_vm._v("Un closure es una funci√≥n que est√° dentro de otra funci√≥n.")])]),_vm._v(" "),_c(\'p\',[_vm._v("Simple y al grano, es una funci√≥n dentro de otra. Ahora bien, ¬øpara qu√© nos puede servir hacer un closure en nuestro c√≥digo? La principal ventaja es que nos permite tener variables en la funci√≥n padre que solo ser√°n accesibles desde la funci√≥n interna (hija), adem√°s de poder acceder tambi√©n a los parametros de la funci√≥n padre. Esto nos permite tener un "),_c(\'strong\',[_vm._v("estado privado")]),_vm._v(" dentro de nuestra funci√≥n pero m√°s interesante a√∫n que este sea "),_c(\'em\',[_c(\'strong\',[_vm._v("un estado reusable")])]),_vm._v(".")]),_vm._v(" "),_c(\'p\',[_vm._v("Una parte importante de los closures es que deben ser retornados por la funci√≥n padre hacia el exterior, a esto se le conoce como funci√≥n de alto nivel o en ingl√©s "),_c(\'em\',[_vm._v("High Order Functions")]),_vm._v(", te invito investigar m√°s sobre ello.")]),_vm._v(" "),_c(\'p\',[_vm._v("Regresando a los closures un ejemplo sencillo ser√≠a:")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true,attrs:{"class":"language-js"}},[_vm._v("const contador = () => {   //funcion padre\\n    let valor = 0;      //estado privado y reusable\\n\\n    return ()=>{        //closure o funcion hija\\n        return valor++;\\n    }\\n}\\n")])]),_vm._v(" "),_c(\'p\',[_vm._v("Ahora para utilizar nuestro closure:")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true,attrs:{"class":"language-js"}},[_vm._v("const contar = contador();  //guardamos el closure en la constante contar\\n\\nconsole.log(contar())   //0\\nconsole.log(contar())   //1\\nconsole.log(contar())   //2\\n")])]),_vm._v(" "),_c(\'p\',[_vm._v("Cada vez que llamamos "),_c(\'em\',[_vm._v("contar()")]),_vm._v(" accedemos al closure, se retorna su valor actual y luego suma 1 a la variable "),_c(\'em\',[_vm._v("valor")]),_vm._v(".")]),_vm._v(" "),_c(\'h3\',[_vm._v("Pruebalo")]),_vm._v(" "),_c(\'p\',{staticClass:"codepen",staticStyle:{"height":"265px","box-sizing":"border-box","display":"flex","align-items":"center","justify-content":"center","border":"2px solid","margin":"1em 0","padding":"1em"},attrs:{"data-height":"265","data-theme-id":"dark","data-default-tab":"js,result","data-user":"anb98","data-slug-hash":"bGbXgJG","data-pen-title":"Closure"}},[_c(\'span\',[_vm._v("See the Pen "),_c(\'a\',{attrs:{"href":"https://codepen.io/anb98/pen/bGbXgJG"}},[_vm._v("\\n  Closure")]),_vm._v(" by Abdiel Martinez ("),_c(\'a\',{attrs:{"href":"https://codepen.io/anb98"}},[_vm._v("@anb98")]),_vm._v(")\\n  on "),_c(\'a\',{attrs:{"href":"https://codepen.io"}},[_vm._v("CodePen")]),_vm._v(".")])]),_vm._v(" "),_c(\'script\',{attrs:{"async":"","src":"https://static.codepen.io/assets/embed/ei.js"}}),_vm._v(" "),_c(\'h2\',[_vm._v("A la pr√°ctica")]),_vm._v(" "),_c(\'p\',[_vm._v("Aunque desde que aprend√≠ este concepto me pareci√≥ muy interesante, a√∫n no hab√≠a conseguido encontrar un caso pr√°ctico, finalmente encontr√© uno que podr√≠a serle util a m√°s de alguno.")]),_vm._v(" "),_c(\'p\',[_vm._v("El problema consiste en realizar consultas a una api, en mi caso realtime de firebase, donde cada resultado quede disponible para que en la siguiente vez que se solicite el mismo dato en lugar de volver a llamar a la "),_c(\'em\',[_vm._v("api")]),_vm._v(", el resultado se devuelva desde el estado local, reduciendo as√≠ el tiempo de respuesta.")]),_vm._v(" "),_c(\'p\',[_vm._v("Mi soluci√≥n:")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true,attrs:{"class":"language-js"}},[_vm._v("import firebase from \'firebase\';\\n\\nconst buscarNodo = (nodo) => {\\n    const data = {};    //estado reusable\\n\\n    return async (valor) => {   //closure asincrono\\n        if (valor) {\\n\\n            const res = data[valor];\\n            if (res)    \\n                return res;  //si existe en el estado local se retorna\\n\\n            else {\\n                const snap = await firebase\\n                .database()\\n                .ref()\\n                .child(nodo)\\n                .child(valor)\\n                .once(\'value\');\\n\\n                if (snap.exists()) {\\n                    const result = snap.val();\\n                    result.key   = valor;\\n                    data[valor]  = result;  //se argega al estado local\\n\\n                    return result;  \\n                }\\n            }\\n        }\\n        \\n        return false;   //si no existe valor de busqueda \\n        //o si no hay resultados en el estado local ni en la api\\n    }\\n}\\n\\nexport default buscarNodo;\\n")])]),_vm._v(" "),_c(\'p\',[_vm._v("¬øQu√© le mejorar√≠as?ü§î")]),_vm._v(" "),_c(\'p\',[_vm._v("Para utilizarlo podr√≠a  ser:")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true,attrs:{"class":"language-js"}},[_vm._v("const buscarAlumno   = buscarNodo(\'alumnos\');\\nconst buscarMateria  = buscarNodo(\'materias\');\\nconst buscarProfesor = buscarNodo(\'profesores\');\\n\\n(async ()=>{  \\n    // esto es conocido como funcion invocada \\n    // inmediatamente, en ingles: \\n    // Immediately invoked function expression (IIFE)\\n\\n\\n    const alumnoEncontrado   = await buscarAlumno( \'idAlumno\');\\n    const materiaEncontrada  = await buscarMateria( \'idMateria\' );\\n    const profesorEncontrado = await buscarProfesor( \'idProfesor\' );\\n\\n})();\\n")])]),_vm._v(" "),_c(\'p\',[_vm._v("Este es mi caso particular, la llamada a firebase podr√≠a ser sustituida por cualquier otra api.")]),_vm._v(" "),_c(\'p\',[_vm._v("¬øQu√© otra idea se te ocurre para utilizar closures?\\nComp√°rtelo en los comentarios üòä")])]) }]',component:{data:function(){return{templateRender:null}},render:function(e){return this.templateRender?this.templateRender():e("div","Rendering")},created:function(){this.templateRender=function(){var e=this.$createElement;this._self._c;return this._m(0)},this.$options.staticRenderFns=[function(){var e=this,n=e.$createElement,o=e._self._c||n;return o("div",{staticClass:"frontmatter-markdown"},[o("h2",[e._v("Qu√© es un closure en JS?")]),e._v(" "),o("p",[e._v("Empecemos por definir que es un closure (algunos los llaman como clausura o cerradura yo prefiero llamarle closure üòÖ). En pocas palabas un closure es:")]),e._v(" "),o("blockquote",[o("p",[e._v("Un closure es una funci√≥n que est√° dentro de otra funci√≥n.")])]),e._v(" "),o("p",[e._v("Simple y al grano, es una funci√≥n dentro de otra. Ahora bien, ¬øpara qu√© nos puede servir hacer un closure en nuestro c√≥digo? La principal ventaja es que nos permite tener variables en la funci√≥n padre que solo ser√°n accesibles desde la funci√≥n interna (hija), adem√°s de poder acceder tambi√©n a los parametros de la funci√≥n padre. Esto nos permite tener un "),o("strong",[e._v("estado privado")]),e._v(" dentro de nuestra funci√≥n pero m√°s interesante a√∫n que este sea "),o("em",[o("strong",[e._v("un estado reusable")])]),e._v(".")]),e._v(" "),o("p",[e._v("Una parte importante de los closures es que deben ser retornados por la funci√≥n padre hacia el exterior, a esto se le conoce como funci√≥n de alto nivel o en ingl√©s "),o("em",[e._v("High Order Functions")]),e._v(", te invito investigar m√°s sobre ello.")]),e._v(" "),o("p",[e._v("Regresando a los closures un ejemplo sencillo ser√≠a:")]),e._v(" "),o("pre",[o("code",{pre:!0,attrs:{class:"language-js"}},[e._v("const contador = () => {   //funcion padre\n    let valor = 0;      //estado privado y reusable\n\n    return ()=>{        //closure o funcion hija\n        return valor++;\n    }\n}\n")])]),e._v(" "),o("p",[e._v("Ahora para utilizar nuestro closure:")]),e._v(" "),o("pre",[o("code",{pre:!0,attrs:{class:"language-js"}},[e._v("const contar = contador();  //guardamos el closure en la constante contar\n\nconsole.log(contar())   //0\nconsole.log(contar())   //1\nconsole.log(contar())   //2\n")])]),e._v(" "),o("p",[e._v("Cada vez que llamamos "),o("em",[e._v("contar()")]),e._v(" accedemos al closure, se retorna su valor actual y luego suma 1 a la variable "),o("em",[e._v("valor")]),e._v(".")]),e._v(" "),o("h3",[e._v("Pruebalo")]),e._v(" "),o("p",{staticClass:"codepen",staticStyle:{height:"265px","box-sizing":"border-box",display:"flex","align-items":"center","justify-content":"center",border:"2px solid",margin:"1em 0",padding:"1em"},attrs:{"data-height":"265","data-theme-id":"dark","data-default-tab":"js,result","data-user":"anb98","data-slug-hash":"bGbXgJG","data-pen-title":"Closure"}},[o("span",[e._v("See the Pen "),o("a",{attrs:{href:"https://codepen.io/anb98/pen/bGbXgJG"}},[e._v("\n  Closure")]),e._v(" by Abdiel Martinez ("),o("a",{attrs:{href:"https://codepen.io/anb98"}},[e._v("@anb98")]),e._v(")\n  on "),o("a",{attrs:{href:"https://codepen.io"}},[e._v("CodePen")]),e._v(".")])]),e._v(" "),o("script",{attrs:{async:"",src:"https://static.codepen.io/assets/embed/ei.js"}}),e._v(" "),o("h2",[e._v("A la pr√°ctica")]),e._v(" "),o("p",[e._v("Aunque desde que aprend√≠ este concepto me pareci√≥ muy interesante, a√∫n no hab√≠a conseguido encontrar un caso pr√°ctico, finalmente encontr√© uno que podr√≠a serle util a m√°s de alguno.")]),e._v(" "),o("p",[e._v("El problema consiste en realizar consultas a una api, en mi caso realtime de firebase, donde cada resultado quede disponible para que en la siguiente vez que se solicite el mismo dato en lugar de volver a llamar a la "),o("em",[e._v("api")]),e._v(", el resultado se devuelva desde el estado local, reduciendo as√≠ el tiempo de respuesta.")]),e._v(" "),o("p",[e._v("Mi soluci√≥n:")]),e._v(" "),o("pre",[o("code",{pre:!0,attrs:{class:"language-js"}},[e._v("import firebase from 'firebase';\n\nconst buscarNodo = (nodo) => {\n    const data = {};    //estado reusable\n\n    return async (valor) => {   //closure asincrono\n        if (valor) {\n\n            const res = data[valor];\n            if (res)    \n                return res;  //si existe en el estado local se retorna\n\n            else {\n                const snap = await firebase\n                .database()\n                .ref()\n                .child(nodo)\n                .child(valor)\n                .once('value');\n\n                if (snap.exists()) {\n                    const result = snap.val();\n                    result.key   = valor;\n                    data[valor]  = result;  //se argega al estado local\n\n                    return result;  \n                }\n            }\n        }\n        \n        return false;   //si no existe valor de busqueda \n        //o si no hay resultados en el estado local ni en la api\n    }\n}\n\nexport default buscarNodo;\n")])]),e._v(" "),o("p",[e._v("¬øQu√© le mejorar√≠as?ü§î")]),e._v(" "),o("p",[e._v("Para utilizarlo podr√≠a  ser:")]),e._v(" "),o("pre",[o("code",{pre:!0,attrs:{class:"language-js"}},[e._v("const buscarAlumno   = buscarNodo('alumnos');\nconst buscarMateria  = buscarNodo('materias');\nconst buscarProfesor = buscarNodo('profesores');\n\n(async ()=>{  \n    // esto es conocido como funcion invocada \n    // inmediatamente, en ingles: \n    // Immediately invoked function expression (IIFE)\n\n\n    const alumnoEncontrado   = await buscarAlumno( 'idAlumno');\n    const materiaEncontrada  = await buscarMateria( 'idMateria' );\n    const profesorEncontrado = await buscarProfesor( 'idProfesor' );\n\n})();\n")])]),e._v(" "),o("p",[e._v("Este es mi caso particular, la llamada a firebase podr√≠a ser sustituida por cualquier otra api.")]),e._v(" "),o("p",[e._v("¬øQu√© otra idea se te ocurre para utilizar closures?\nComp√°rtelo en los comentarios üòä")])])}]}}}}}}]);