(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{263:function(e,n){e.exports={body:"Esta es una de esas características de JavaScript que usualmente pasan desapercibidas. Conocerlas, sin embargo, te ayudará a profundizar en el lenguaje y todas sus posibilidades. ¿De qué estamos hablando?\r\n\r\n## ¿En qué consisten?\r\n\r\nEste tipo de funciones tienen la capacidad de pausar y reanudar su ejecución posteriormente, lo que las hace ideales para trabajar con conjuntos de datos grandes y potencialmente infinitos.\r\n\r\nUna función generadora se define utilizando la palabra clave `function*` en lugar de `function`. Dentro de la función generadora, se utiliza la palabra clave `yield` para pausar la ejecución y devolver un valor al iterador. Cuando se llama nuevamente a la función generadora, la ejecución se reanuda desde el punto donde se pausó.\r\n\r\nLas funciones generadoras pueden ser utilizadas en combinación con la sintaxis `for...of` para iterar de manera sencilla sobre los valores generados.\r\n\r\n> Las funciones generadoras no pueden ser definidas mediante el uso de Arrow functions.\r\n\r\n## ¿Qué genera una función generadora?\r\n\r\nAl ejecutar una función generadora, su código no se ejecuta inmediatamente, en su lugar, devuelve un objeto iterador llamado `Generator`.\r\n\r\nEl objeto `Generator` tiene 3 métodos que podemos llamar estos son:\r\n\r\n- `next` que retorna un objeto con las propiedades: `value`, que corresponde al valor de la expresión `yield` y la propiedad `done` que nos indica si hemos consumido el ultimo valor de la iteración.\r\n- `return` que retorna el valor que le pasamos como argumento y finaliza el generador.\r\n- `throw` que lanza como error el valor que enviemos como argumento y también finaliza el generador\r\n\r\nImagina que tenemos la siguiente función generadora:\r\n\r\n```js\r\nfunction* getGenerator() {\r\n  yield \"ejemplo 1\";\r\n  yield \"ejemplo 2\";\r\n}\r\n\r\nconst generator = getGenerator();\r\n\r\nconsole.log(generator.next());\r\n// { value: 'ejemplo 1', done: false }\r\n\r\nconsole.log(generator.return(\"valor de retorno\"));\r\n// { value: 'valor de retorno', done: true }\r\n\r\nconsole.log(generator.throw(\"mensaje de error\"));\r\n// Error: mensaje de error\r\n```\r\n\r\nPara utilizar el generador con un `for-of`, se haría de la siguiente manera:\r\n\r\n```js\r\nfor (const value of getGenerator()) {\r\n  console.log(value);\r\n  // 'ejemplo 1'\r\n  // 'ejemplo 2'\r\n}\r\n```\r\n\r\nSi quisieras utilizar los métodos de los arrays para los resultados del generador, sería tan sencillo como usar la función `Array.from()` de la siguiente manera.\r\n\r\n```js\r\nArray.from(getGenerator()).map(item => item.toUpperCase());\r\n// [ 'EJEMPLO 1', 'EJEMPLO 2' ]\r\n```\r\n\r\n## Uso avanzado\r\n\r\n- El método `next` del objeto generador puede recibir un parámetro y así cambiar el estado interno de la función generadora. Ejemplo:\r\n\r\n```js\r\nfunction* getGenerator() {\r\n  const value = yield \"ejemplo 1\";\r\n  yield value || \"ejemplo 2\";\r\n}\r\n\r\nconsole.log(generator.next());\r\n// { value: 'ejemplo 1', done: false }\r\n\r\nconsole.log(generator.next(\"valor externo\"));\r\n// { value: 'valor externo', done: false }\r\n```\r\n\r\nEn este caso, al realizar la llamada al método `next` por segunda vez, pasamos un valor que es recibido dentro de la función generadora a través de la expresión `yield` previa.\r\n\r\n- Otro uso avanzado es delegar la iteración a otro generador u [objeto iterable](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Iteration_protocols#iterables_nativos) mediante el uso de la expresión `yield*`.\r\n\r\nImagina el siguiente caso sin delegar la iteración:\r\n\r\n```js\r\nfunction* getGenerator() {\r\n  yield \"ejemplo 1\";\r\n  yield [\"valor 1\", \"valor 2\"];\r\n}\r\n\r\nfor (const value of getGenerator()) {\r\n  console.log(value);\r\n  // 'ejemplo 1'  --\x3e primera iteracion\r\n  // [ 'valor 1', 'valor 2' ]  --\x3e segunda iteracion\r\n}\r\n```\r\n\r\nMira como cambia si delegamos la iteración con el uso de `yield*`:\r\n\r\n```js\r\nfunction* getGenerator() {\r\n  yield \"ejemplo 1\";\r\n  yield* [\"valor 1\", \"valor 2\"];\r\n}\r\n\r\nfor (const value of getGenerator()) {\r\n  console.log(value);\r\n  // 'ejemplo 1'  --\x3e primera iteracion\r\n  // 'valor 1'  --\x3e segunda iteracion\r\n  // 'valor 2'  --\x3e tercera iteracion\r\n}\r\n```\r\n\r\nAl utilizar `yield*`, podemos recorrer el `array` como parte de las iteraciones del generador. También podemos hacer lo mismo al devolver con la expresión `yield*` otro generador, un `string`, un `Map`, un `WeakMap`, un `Set` o un `WeakSet`.\r\n\r\n## Caso práctico de uso\r\n\r\nImagina que necesitas solicitar datos de una API que utiliza paginación. Podrías implementar un enfoque como el siguiente:\r\n\r\n```js\r\nasync function* getUserData() {\r\n  let page = 1;\r\n  while (true) {\r\n    const response = await fetch(\r\n      `https://jsonplaceholder.typicode.com/todos/${page}`\r\n    );\r\n    yield response.json();\r\n\r\n    page++;\r\n  }\r\n}\r\n\r\n(async () => {\r\n  const request = getUserData();\r\n  console.log(await request.next());\r\n  /* { \r\n  value: {\r\n    userId: 1,\r\n    id: 1,\r\n    title: 'delectus aut autem',\r\n    completed: false\r\n  },\r\n  done: false\r\n} */\r\n\r\n  console.log(await request.next());\r\n  /* {\r\n  value: {\r\n    userId: 1,\r\n    id: 2,\r\n    title: 'quis ut nam facilis et officia qui',\r\n    completed: false\r\n  },\r\n  done: false\r\n} */\r\n})();\r\n```\r\n\r\nImplementándolo de esta manera por cada iteración realizada se realizaría una request a la API aumentando la pagina solicitada en cada iteración.\r\n\r\n¿Qué opinas de las funciones generadoras? ¿Qué otros casos prácticos encuentras para su uso? Cuéntamelo en los comentarios.\r\n\r\n## Fuentes\r\n\r\n- [Documentación de MDN: Declaración de función](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Statements/function*)\r\n- [Documentación de MDN: Protocolos de iteración - Iterables nativos](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Iteration_protocols#iterables_nativos)\r\n- [Documentación de MDN: Palabra clave yield\\*](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Operators/yield*)\r\n- [Documentación de MDN: Iteradores y generadores](https://developer.mozilla.org/es/docs/Web/JavaScript/Guide/Iterators_and_generators)\r\n- [Documentación de MDN: Objeto Generador](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Generator)\r\n",html:"<p>Esta es una de esas características de JavaScript que usualmente pasan desapercibidas. Conocerlas, sin embargo, te ayudará a profundizar en el lenguaje y todas sus posibilidades. ¿De qué estamos hablando?</p>\n<h2>¿En qué consisten?</h2>\n<p>Este tipo de funciones tienen la capacidad de pausar y reanudar su ejecución posteriormente, lo que las hace ideales para trabajar con conjuntos de datos grandes y potencialmente infinitos.</p>\n<p>Una función generadora se define utilizando la palabra clave <code>function*</code> en lugar de <code>function</code>. Dentro de la función generadora, se utiliza la palabra clave <code>yield</code> para pausar la ejecución y devolver un valor al iterador. Cuando se llama nuevamente a la función generadora, la ejecución se reanuda desde el punto donde se pausó.</p>\n<p>Las funciones generadoras pueden ser utilizadas en combinación con la sintaxis <code>for...of</code> para iterar de manera sencilla sobre los valores generados.</p>\n<blockquote>\n<p>Las funciones generadoras no pueden ser definidas mediante el uso de Arrow functions.</p>\n</blockquote>\n<h2>¿Qué genera una función generadora?</h2>\n<p>Al ejecutar una función generadora, su código no se ejecuta inmediatamente, en su lugar, devuelve un objeto iterador llamado <code>Generator</code>.</p>\n<p>El objeto <code>Generator</code> tiene 3 métodos que podemos llamar estos son:</p>\n<ul>\n<li><code>next</code> que retorna un objeto con las propiedades: <code>value</code>, que corresponde al valor de la expresión <code>yield</code> y la propiedad <code>done</code> que nos indica si hemos consumido el ultimo valor de la iteración.</li>\n<li><code>return</code> que retorna el valor que le pasamos como argumento y finaliza el generador.</li>\n<li><code>throw</code> que lanza como error el valor que enviemos como argumento y también finaliza el generador</li>\n</ul>\n<p>Imagina que tenemos la siguiente función generadora:</p>\n<pre><code class=\"language-js\">function* getGenerator() {\n  yield &quot;ejemplo 1&quot;;\n  yield &quot;ejemplo 2&quot;;\n}\n\nconst generator = getGenerator();\n\nconsole.log(generator.next());\n// { value: 'ejemplo 1', done: false }\n\nconsole.log(generator.return(&quot;valor de retorno&quot;));\n// { value: 'valor de retorno', done: true }\n\nconsole.log(generator.throw(&quot;mensaje de error&quot;));\n// Error: mensaje de error\n</code></pre>\n<p>Para utilizar el generador con un <code>for-of</code>, se haría de la siguiente manera:</p>\n<pre><code class=\"language-js\">for (const value of getGenerator()) {\n  console.log(value);\n  // 'ejemplo 1'\n  // 'ejemplo 2'\n}\n</code></pre>\n<p>Si quisieras utilizar los métodos de los arrays para los resultados del generador, sería tan sencillo como usar la función <code>Array.from()</code> de la siguiente manera.</p>\n<pre><code class=\"language-js\">Array.from(getGenerator()).map(item =&gt; item.toUpperCase());\n// [ 'EJEMPLO 1', 'EJEMPLO 2' ]\n</code></pre>\n<h2>Uso avanzado</h2>\n<ul>\n<li>El método <code>next</code> del objeto generador puede recibir un parámetro y así cambiar el estado interno de la función generadora. Ejemplo:</li>\n</ul>\n<pre><code class=\"language-js\">function* getGenerator() {\n  const value = yield &quot;ejemplo 1&quot;;\n  yield value || &quot;ejemplo 2&quot;;\n}\n\nconsole.log(generator.next());\n// { value: 'ejemplo 1', done: false }\n\nconsole.log(generator.next(&quot;valor externo&quot;));\n// { value: 'valor externo', done: false }\n</code></pre>\n<p>En este caso, al realizar la llamada al método <code>next</code> por segunda vez, pasamos un valor que es recibido dentro de la función generadora a través de la expresión <code>yield</code> previa.</p>\n<ul>\n<li>Otro uso avanzado es delegar la iteración a otro generador u <a href=\"https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Iteration_protocols#iterables_nativos\">objeto iterable</a> mediante el uso de la expresión <code>yield*</code>.</li>\n</ul>\n<p>Imagina el siguiente caso sin delegar la iteración:</p>\n<pre><code class=\"language-js\">function* getGenerator() {\n  yield &quot;ejemplo 1&quot;;\n  yield [&quot;valor 1&quot;, &quot;valor 2&quot;];\n}\n\nfor (const value of getGenerator()) {\n  console.log(value);\n  // 'ejemplo 1'  --&gt; primera iteracion\n  // [ 'valor 1', 'valor 2' ]  --&gt; segunda iteracion\n}\n</code></pre>\n<p>Mira como cambia si delegamos la iteración con el uso de <code>yield*</code>:</p>\n<pre><code class=\"language-js\">function* getGenerator() {\n  yield &quot;ejemplo 1&quot;;\n  yield* [&quot;valor 1&quot;, &quot;valor 2&quot;];\n}\n\nfor (const value of getGenerator()) {\n  console.log(value);\n  // 'ejemplo 1'  --&gt; primera iteracion\n  // 'valor 1'  --&gt; segunda iteracion\n  // 'valor 2'  --&gt; tercera iteracion\n}\n</code></pre>\n<p>Al utilizar <code>yield*</code>, podemos recorrer el <code>array</code> como parte de las iteraciones del generador. También podemos hacer lo mismo al devolver con la expresión <code>yield*</code> otro generador, un <code>string</code>, un <code>Map</code>, un <code>WeakMap</code>, un <code>Set</code> o un <code>WeakSet</code>.</p>\n<h2>Caso práctico de uso</h2>\n<p>Imagina que necesitas solicitar datos de una API que utiliza paginación. Podrías implementar un enfoque como el siguiente:</p>\n<pre><code class=\"language-js\">async function* getUserData() {\n  let page = 1;\n  while (true) {\n    const response = await fetch(\n      `https://jsonplaceholder.typicode.com/todos/${page}`\n    );\n    yield response.json();\n\n    page++;\n  }\n}\n\n(async () =&gt; {\n  const request = getUserData();\n  console.log(await request.next());\n  /* { \n  value: {\n    userId: 1,\n    id: 1,\n    title: 'delectus aut autem',\n    completed: false\n  },\n  done: false\n} */\n\n  console.log(await request.next());\n  /* {\n  value: {\n    userId: 1,\n    id: 2,\n    title: 'quis ut nam facilis et officia qui',\n    completed: false\n  },\n  done: false\n} */\n})();\n</code></pre>\n<p>Implementándolo de esta manera por cada iteración realizada se realizaría una request a la API aumentando la pagina solicitada en cada iteración.</p>\n<p>¿Qué opinas de las funciones generadoras? ¿Qué otros casos prácticos encuentras para su uso? Cuéntamelo en los comentarios.</p>\n<h2>Fuentes</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Statements/function*\">Documentación de MDN: Declaración de función</a></li>\n<li><a href=\"https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Iteration_protocols#iterables_nativos\">Documentación de MDN: Protocolos de iteración - Iterables nativos</a></li>\n<li><a href=\"https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Operators/yield*\">Documentación de MDN: Palabra clave yield*</a></li>\n<li><a href=\"https://developer.mozilla.org/es/docs/Web/JavaScript/Guide/Iterators_and_generators\">Documentación de MDN: Iteradores y generadores</a></li>\n<li><a href=\"https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Generator\">Documentación de MDN: Objeto Generador</a></li>\n</ul>\n",attributes:{_meta:{resourcePath:"E:\\Projects\\blog\\assets\\articulos\\Descubriendo-las-Funciones-Generadoras-en-JavaScript.md"}},vue:{render:"return function render() { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _vm._m(0) }",staticRenderFns:'return [function () { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'div\',{staticClass:"frontmatter-markdown"},[_c(\'p\',[_vm._v("Esta es una de esas características de JavaScript que usualmente pasan desapercibidas. Conocerlas, sin embargo, te ayudará a profundizar en el lenguaje y todas sus posibilidades. ¿De qué estamos hablando?")]),_vm._v(" "),_c(\'h2\',[_vm._v("¿En qué consisten?")]),_vm._v(" "),_c(\'p\',[_vm._v("Este tipo de funciones tienen la capacidad de pausar y reanudar su ejecución posteriormente, lo que las hace ideales para trabajar con conjuntos de datos grandes y potencialmente infinitos.")]),_vm._v(" "),_c(\'p\',[_vm._v("Una función generadora se define utilizando la palabra clave "),_c(\'code\',{pre:true},[_vm._v("function*")]),_vm._v(" en lugar de "),_c(\'code\',{pre:true},[_vm._v("function")]),_vm._v(". Dentro de la función generadora, se utiliza la palabra clave "),_c(\'code\',{pre:true},[_vm._v("yield")]),_vm._v(" para pausar la ejecución y devolver un valor al iterador. Cuando se llama nuevamente a la función generadora, la ejecución se reanuda desde el punto donde se pausó.")]),_vm._v(" "),_c(\'p\',[_vm._v("Las funciones generadoras pueden ser utilizadas en combinación con la sintaxis "),_c(\'code\',{pre:true},[_vm._v("for...of")]),_vm._v(" para iterar de manera sencilla sobre los valores generados.")]),_vm._v(" "),_c(\'blockquote\',[_c(\'p\',[_vm._v("Las funciones generadoras no pueden ser definidas mediante el uso de Arrow functions.")])]),_vm._v(" "),_c(\'h2\',[_vm._v("¿Qué genera una función generadora?")]),_vm._v(" "),_c(\'p\',[_vm._v("Al ejecutar una función generadora, su código no se ejecuta inmediatamente, en su lugar, devuelve un objeto iterador llamado "),_c(\'code\',{pre:true},[_vm._v("Generator")]),_vm._v(".")]),_vm._v(" "),_c(\'p\',[_vm._v("El objeto "),_c(\'code\',{pre:true},[_vm._v("Generator")]),_vm._v(" tiene 3 métodos que podemos llamar estos son:")]),_vm._v(" "),_c(\'ul\',[_c(\'li\',[_c(\'code\',{pre:true},[_vm._v("next")]),_vm._v(" que retorna un objeto con las propiedades: "),_c(\'code\',{pre:true},[_vm._v("value")]),_vm._v(", que corresponde al valor de la expresión "),_c(\'code\',{pre:true},[_vm._v("yield")]),_vm._v(" y la propiedad "),_c(\'code\',{pre:true},[_vm._v("done")]),_vm._v(" que nos indica si hemos consumido el ultimo valor de la iteración.")]),_vm._v(" "),_c(\'li\',[_c(\'code\',{pre:true},[_vm._v("return")]),_vm._v(" que retorna el valor que le pasamos como argumento y finaliza el generador.")]),_vm._v(" "),_c(\'li\',[_c(\'code\',{pre:true},[_vm._v("throw")]),_vm._v(" que lanza como error el valor que enviemos como argumento y también finaliza el generador")])]),_vm._v(" "),_c(\'p\',[_vm._v("Imagina que tenemos la siguiente función generadora:")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true,attrs:{"class":"language-js"}},[_vm._v("function* getGenerator() {\\n  yield \\"ejemplo 1\\";\\n  yield \\"ejemplo 2\\";\\n}\\n\\nconst generator = getGenerator();\\n\\nconsole.log(generator.next());\\n// { value: \'ejemplo 1\', done: false }\\n\\nconsole.log(generator.return(\\"valor de retorno\\"));\\n// { value: \'valor de retorno\', done: true }\\n\\nconsole.log(generator.throw(\\"mensaje de error\\"));\\n// Error: mensaje de error\\n")])]),_vm._v(" "),_c(\'p\',[_vm._v("Para utilizar el generador con un "),_c(\'code\',{pre:true},[_vm._v("for-of")]),_vm._v(", se haría de la siguiente manera:")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true,attrs:{"class":"language-js"}},[_vm._v("for (const value of getGenerator()) {\\n  console.log(value);\\n  // \'ejemplo 1\'\\n  // \'ejemplo 2\'\\n}\\n")])]),_vm._v(" "),_c(\'p\',[_vm._v("Si quisieras utilizar los métodos de los arrays para los resultados del generador, sería tan sencillo como usar la función "),_c(\'code\',{pre:true},[_vm._v("Array.from()")]),_vm._v(" de la siguiente manera.")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true,attrs:{"class":"language-js"}},[_vm._v("Array.from(getGenerator()).map(item => item.toUpperCase());\\n// [ \'EJEMPLO 1\', \'EJEMPLO 2\' ]\\n")])]),_vm._v(" "),_c(\'h2\',[_vm._v("Uso avanzado")]),_vm._v(" "),_c(\'ul\',[_c(\'li\',[_vm._v("El método "),_c(\'code\',{pre:true},[_vm._v("next")]),_vm._v(" del objeto generador puede recibir un parámetro y así cambiar el estado interno de la función generadora. Ejemplo:")])]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true,attrs:{"class":"language-js"}},[_vm._v("function* getGenerator() {\\n  const value = yield \\"ejemplo 1\\";\\n  yield value || \\"ejemplo 2\\";\\n}\\n\\nconsole.log(generator.next());\\n// { value: \'ejemplo 1\', done: false }\\n\\nconsole.log(generator.next(\\"valor externo\\"));\\n// { value: \'valor externo\', done: false }\\n")])]),_vm._v(" "),_c(\'p\',[_vm._v("En este caso, al realizar la llamada al método "),_c(\'code\',{pre:true},[_vm._v("next")]),_vm._v(" por segunda vez, pasamos un valor que es recibido dentro de la función generadora a través de la expresión "),_c(\'code\',{pre:true},[_vm._v("yield")]),_vm._v(" previa.")]),_vm._v(" "),_c(\'ul\',[_c(\'li\',[_vm._v("Otro uso avanzado es delegar la iteración a otro generador u "),_c(\'a\',{attrs:{"href":"https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Iteration_protocols#iterables_nativos"}},[_vm._v("objeto iterable")]),_vm._v(" mediante el uso de la expresión "),_c(\'code\',{pre:true},[_vm._v("yield*")]),_vm._v(".")])]),_vm._v(" "),_c(\'p\',[_vm._v("Imagina el siguiente caso sin delegar la iteración:")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true,attrs:{"class":"language-js"}},[_vm._v("function* getGenerator() {\\n  yield \\"ejemplo 1\\";\\n  yield [\\"valor 1\\", \\"valor 2\\"];\\n}\\n\\nfor (const value of getGenerator()) {\\n  console.log(value);\\n  // \'ejemplo 1\'  --\x3e primera iteracion\\n  // [ \'valor 1\', \'valor 2\' ]  --\x3e segunda iteracion\\n}\\n")])]),_vm._v(" "),_c(\'p\',[_vm._v("Mira como cambia si delegamos la iteración con el uso de "),_c(\'code\',{pre:true},[_vm._v("yield*")]),_vm._v(":")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true,attrs:{"class":"language-js"}},[_vm._v("function* getGenerator() {\\n  yield \\"ejemplo 1\\";\\n  yield* [\\"valor 1\\", \\"valor 2\\"];\\n}\\n\\nfor (const value of getGenerator()) {\\n  console.log(value);\\n  // \'ejemplo 1\'  --\x3e primera iteracion\\n  // \'valor 1\'  --\x3e segunda iteracion\\n  // \'valor 2\'  --\x3e tercera iteracion\\n}\\n")])]),_vm._v(" "),_c(\'p\',[_vm._v("Al utilizar "),_c(\'code\',{pre:true},[_vm._v("yield*")]),_vm._v(", podemos recorrer el "),_c(\'code\',{pre:true},[_vm._v("array")]),_vm._v(" como parte de las iteraciones del generador. También podemos hacer lo mismo al devolver con la expresión "),_c(\'code\',{pre:true},[_vm._v("yield*")]),_vm._v(" otro generador, un "),_c(\'code\',{pre:true},[_vm._v("string")]),_vm._v(", un "),_c(\'code\',{pre:true},[_vm._v("Map")]),_vm._v(", un "),_c(\'code\',{pre:true},[_vm._v("WeakMap")]),_vm._v(", un "),_c(\'code\',{pre:true},[_vm._v("Set")]),_vm._v(" o un "),_c(\'code\',{pre:true},[_vm._v("WeakSet")]),_vm._v(".")]),_vm._v(" "),_c(\'h2\',[_vm._v("Caso práctico de uso")]),_vm._v(" "),_c(\'p\',[_vm._v("Imagina que necesitas solicitar datos de una API que utiliza paginación. Podrías implementar un enfoque como el siguiente:")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true,attrs:{"class":"language-js"}},[_vm._v("async function* getUserData() {\\n  let page = 1;\\n  while (true) {\\n    const response = await fetch(\\n      `https://jsonplaceholder.typicode.com/todos/${page}`\\n    );\\n    yield response.json();\\n\\n    page++;\\n  }\\n}\\n\\n(async () => {\\n  const request = getUserData();\\n  console.log(await request.next());\\n  /* { \\n  value: {\\n    userId: 1,\\n    id: 1,\\n    title: \'delectus aut autem\',\\n    completed: false\\n  },\\n  done: false\\n} */\\n\\n  console.log(await request.next());\\n  /* {\\n  value: {\\n    userId: 1,\\n    id: 2,\\n    title: \'quis ut nam facilis et officia qui\',\\n    completed: false\\n  },\\n  done: false\\n} */\\n})();\\n")])]),_vm._v(" "),_c(\'p\',[_vm._v("Implementándolo de esta manera por cada iteración realizada se realizaría una request a la API aumentando la pagina solicitada en cada iteración.")]),_vm._v(" "),_c(\'p\',[_vm._v("¿Qué opinas de las funciones generadoras? ¿Qué otros casos prácticos encuentras para su uso? Cuéntamelo en los comentarios.")]),_vm._v(" "),_c(\'h2\',[_vm._v("Fuentes")]),_vm._v(" "),_c(\'ul\',[_c(\'li\',[_c(\'a\',{attrs:{"href":"https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Statements/function*"}},[_vm._v("Documentación de MDN: Declaración de función")])]),_vm._v(" "),_c(\'li\',[_c(\'a\',{attrs:{"href":"https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Iteration_protocols#iterables_nativos"}},[_vm._v("Documentación de MDN: Protocolos de iteración - Iterables nativos")])]),_vm._v(" "),_c(\'li\',[_c(\'a\',{attrs:{"href":"https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Operators/yield*"}},[_vm._v("Documentación de MDN: Palabra clave yield*")])]),_vm._v(" "),_c(\'li\',[_c(\'a\',{attrs:{"href":"https://developer.mozilla.org/es/docs/Web/JavaScript/Guide/Iterators_and_generators"}},[_vm._v("Documentación de MDN: Iteradores y generadores")])]),_vm._v(" "),_c(\'li\',[_c(\'a\',{attrs:{"href":"https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Generator"}},[_vm._v("Documentación de MDN: Objeto Generador")])])])]) }]',component:{data:function(){return{templateRender:null}},render:function(e){return this.templateRender?this.templateRender():e("div","Rendering")},created:function(){this.templateRender=function(){var e=this.$createElement;this._self._c;return this._m(0)},this.$options.staticRenderFns=[function(){var e=this,n=e.$createElement,o=e._self._c||n;return o("div",{staticClass:"frontmatter-markdown"},[o("p",[e._v("Esta es una de esas características de JavaScript que usualmente pasan desapercibidas. Conocerlas, sin embargo, te ayudará a profundizar en el lenguaje y todas sus posibilidades. ¿De qué estamos hablando?")]),e._v(" "),o("h2",[e._v("¿En qué consisten?")]),e._v(" "),o("p",[e._v("Este tipo de funciones tienen la capacidad de pausar y reanudar su ejecución posteriormente, lo que las hace ideales para trabajar con conjuntos de datos grandes y potencialmente infinitos.")]),e._v(" "),o("p",[e._v("Una función generadora se define utilizando la palabra clave "),o("code",{pre:!0},[e._v("function*")]),e._v(" en lugar de "),o("code",{pre:!0},[e._v("function")]),e._v(". Dentro de la función generadora, se utiliza la palabra clave "),o("code",{pre:!0},[e._v("yield")]),e._v(" para pausar la ejecución y devolver un valor al iterador. Cuando se llama nuevamente a la función generadora, la ejecución se reanuda desde el punto donde se pausó.")]),e._v(" "),o("p",[e._v("Las funciones generadoras pueden ser utilizadas en combinación con la sintaxis "),o("code",{pre:!0},[e._v("for...of")]),e._v(" para iterar de manera sencilla sobre los valores generados.")]),e._v(" "),o("blockquote",[o("p",[e._v("Las funciones generadoras no pueden ser definidas mediante el uso de Arrow functions.")])]),e._v(" "),o("h2",[e._v("¿Qué genera una función generadora?")]),e._v(" "),o("p",[e._v("Al ejecutar una función generadora, su código no se ejecuta inmediatamente, en su lugar, devuelve un objeto iterador llamado "),o("code",{pre:!0},[e._v("Generator")]),e._v(".")]),e._v(" "),o("p",[e._v("El objeto "),o("code",{pre:!0},[e._v("Generator")]),e._v(" tiene 3 métodos que podemos llamar estos son:")]),e._v(" "),o("ul",[o("li",[o("code",{pre:!0},[e._v("next")]),e._v(" que retorna un objeto con las propiedades: "),o("code",{pre:!0},[e._v("value")]),e._v(", que corresponde al valor de la expresión "),o("code",{pre:!0},[e._v("yield")]),e._v(" y la propiedad "),o("code",{pre:!0},[e._v("done")]),e._v(" que nos indica si hemos consumido el ultimo valor de la iteración.")]),e._v(" "),o("li",[o("code",{pre:!0},[e._v("return")]),e._v(" que retorna el valor que le pasamos como argumento y finaliza el generador.")]),e._v(" "),o("li",[o("code",{pre:!0},[e._v("throw")]),e._v(" que lanza como error el valor que enviemos como argumento y también finaliza el generador")])]),e._v(" "),o("p",[e._v("Imagina que tenemos la siguiente función generadora:")]),e._v(" "),o("pre",[o("code",{pre:!0,attrs:{class:"language-js"}},[e._v('function* getGenerator() {\n  yield "ejemplo 1";\n  yield "ejemplo 2";\n}\n\nconst generator = getGenerator();\n\nconsole.log(generator.next());\n// { value: \'ejemplo 1\', done: false }\n\nconsole.log(generator.return("valor de retorno"));\n// { value: \'valor de retorno\', done: true }\n\nconsole.log(generator.throw("mensaje de error"));\n// Error: mensaje de error\n')])]),e._v(" "),o("p",[e._v("Para utilizar el generador con un "),o("code",{pre:!0},[e._v("for-of")]),e._v(", se haría de la siguiente manera:")]),e._v(" "),o("pre",[o("code",{pre:!0,attrs:{class:"language-js"}},[e._v("for (const value of getGenerator()) {\n  console.log(value);\n  // 'ejemplo 1'\n  // 'ejemplo 2'\n}\n")])]),e._v(" "),o("p",[e._v("Si quisieras utilizar los métodos de los arrays para los resultados del generador, sería tan sencillo como usar la función "),o("code",{pre:!0},[e._v("Array.from()")]),e._v(" de la siguiente manera.")]),e._v(" "),o("pre",[o("code",{pre:!0,attrs:{class:"language-js"}},[e._v("Array.from(getGenerator()).map(item => item.toUpperCase());\n// [ 'EJEMPLO 1', 'EJEMPLO 2' ]\n")])]),e._v(" "),o("h2",[e._v("Uso avanzado")]),e._v(" "),o("ul",[o("li",[e._v("El método "),o("code",{pre:!0},[e._v("next")]),e._v(" del objeto generador puede recibir un parámetro y así cambiar el estado interno de la función generadora. Ejemplo:")])]),e._v(" "),o("pre",[o("code",{pre:!0,attrs:{class:"language-js"}},[e._v('function* getGenerator() {\n  const value = yield "ejemplo 1";\n  yield value || "ejemplo 2";\n}\n\nconsole.log(generator.next());\n// { value: \'ejemplo 1\', done: false }\n\nconsole.log(generator.next("valor externo"));\n// { value: \'valor externo\', done: false }\n')])]),e._v(" "),o("p",[e._v("En este caso, al realizar la llamada al método "),o("code",{pre:!0},[e._v("next")]),e._v(" por segunda vez, pasamos un valor que es recibido dentro de la función generadora a través de la expresión "),o("code",{pre:!0},[e._v("yield")]),e._v(" previa.")]),e._v(" "),o("ul",[o("li",[e._v("Otro uso avanzado es delegar la iteración a otro generador u "),o("a",{attrs:{href:"https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Iteration_protocols#iterables_nativos"}},[e._v("objeto iterable")]),e._v(" mediante el uso de la expresión "),o("code",{pre:!0},[e._v("yield*")]),e._v(".")])]),e._v(" "),o("p",[e._v("Imagina el siguiente caso sin delegar la iteración:")]),e._v(" "),o("pre",[o("code",{pre:!0,attrs:{class:"language-js"}},[e._v("function* getGenerator() {\n  yield \"ejemplo 1\";\n  yield [\"valor 1\", \"valor 2\"];\n}\n\nfor (const value of getGenerator()) {\n  console.log(value);\n  // 'ejemplo 1'  --\x3e primera iteracion\n  // [ 'valor 1', 'valor 2' ]  --\x3e segunda iteracion\n}\n")])]),e._v(" "),o("p",[e._v("Mira como cambia si delegamos la iteración con el uso de "),o("code",{pre:!0},[e._v("yield*")]),e._v(":")]),e._v(" "),o("pre",[o("code",{pre:!0,attrs:{class:"language-js"}},[e._v("function* getGenerator() {\n  yield \"ejemplo 1\";\n  yield* [\"valor 1\", \"valor 2\"];\n}\n\nfor (const value of getGenerator()) {\n  console.log(value);\n  // 'ejemplo 1'  --\x3e primera iteracion\n  // 'valor 1'  --\x3e segunda iteracion\n  // 'valor 2'  --\x3e tercera iteracion\n}\n")])]),e._v(" "),o("p",[e._v("Al utilizar "),o("code",{pre:!0},[e._v("yield*")]),e._v(", podemos recorrer el "),o("code",{pre:!0},[e._v("array")]),e._v(" como parte de las iteraciones del generador. También podemos hacer lo mismo al devolver con la expresión "),o("code",{pre:!0},[e._v("yield*")]),e._v(" otro generador, un "),o("code",{pre:!0},[e._v("string")]),e._v(", un "),o("code",{pre:!0},[e._v("Map")]),e._v(", un "),o("code",{pre:!0},[e._v("WeakMap")]),e._v(", un "),o("code",{pre:!0},[e._v("Set")]),e._v(" o un "),o("code",{pre:!0},[e._v("WeakSet")]),e._v(".")]),e._v(" "),o("h2",[e._v("Caso práctico de uso")]),e._v(" "),o("p",[e._v("Imagina que necesitas solicitar datos de una API que utiliza paginación. Podrías implementar un enfoque como el siguiente:")]),e._v(" "),o("pre",[o("code",{pre:!0,attrs:{class:"language-js"}},[e._v("async function* getUserData() {\n  let page = 1;\n  while (true) {\n    const response = await fetch(\n      `https://jsonplaceholder.typicode.com/todos/${page}`\n    );\n    yield response.json();\n\n    page++;\n  }\n}\n\n(async () => {\n  const request = getUserData();\n  console.log(await request.next());\n  /* { \n  value: {\n    userId: 1,\n    id: 1,\n    title: 'delectus aut autem',\n    completed: false\n  },\n  done: false\n} */\n\n  console.log(await request.next());\n  /* {\n  value: {\n    userId: 1,\n    id: 2,\n    title: 'quis ut nam facilis et officia qui',\n    completed: false\n  },\n  done: false\n} */\n})();\n")])]),e._v(" "),o("p",[e._v("Implementándolo de esta manera por cada iteración realizada se realizaría una request a la API aumentando la pagina solicitada en cada iteración.")]),e._v(" "),o("p",[e._v("¿Qué opinas de las funciones generadoras? ¿Qué otros casos prácticos encuentras para su uso? Cuéntamelo en los comentarios.")]),e._v(" "),o("h2",[e._v("Fuentes")]),e._v(" "),o("ul",[o("li",[o("a",{attrs:{href:"https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Statements/function*"}},[e._v("Documentación de MDN: Declaración de función")])]),e._v(" "),o("li",[o("a",{attrs:{href:"https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Iteration_protocols#iterables_nativos"}},[e._v("Documentación de MDN: Protocolos de iteración - Iterables nativos")])]),e._v(" "),o("li",[o("a",{attrs:{href:"https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Operators/yield*"}},[e._v("Documentación de MDN: Palabra clave yield*")])]),e._v(" "),o("li",[o("a",{attrs:{href:"https://developer.mozilla.org/es/docs/Web/JavaScript/Guide/Iterators_and_generators"}},[e._v("Documentación de MDN: Iteradores y generadores")])]),e._v(" "),o("li",[o("a",{attrs:{href:"https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Generator"}},[e._v("Documentación de MDN: Objeto Generador")])])])])}]}}}}}}]);