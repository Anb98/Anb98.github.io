(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{261:function(e,n){e.exports={body:'## QuÃ© es un closure en JS?\r\nEmpecemos por definir que es un closure (algunos las llaman como clausura o cerradura yo prefiero llamarle closureðŸ˜…). En pocas palabas un closure es:\r\n> Un closure es una funciÃ³n que estÃ¡ dentro de otra funcion.\r\n\r\nSimple y al grano es una funciÃ³n dentro de otra. Ahora bien Â¿para quÃ© nos puede servir hacer un closure en nuestro codigo? La principal ventaja es que nos permite tener variables en la funcion padre que solo serÃ¡n accesibles desde la funcion interna (hija), ademÃ¡s de poder acceder tambien a los parametros de la funciÃ³n padre. Esto nos permite tener un **estado privado** dentro de nuestra funciÃ³n pero mÃ¡s interesante aun que este sea ***un estado reusable***.\r\n\r\nUn parte importante de los closures es que deben ser retornados por la funcion padre hacia el exterior, a esto se le conoce como funciÃ³n de alto nivel o en inglÃ©s *High Order Functions*, te invito investigar mÃ¡s sobre ello.\r\n\r\nRegresando a los closures un ejemplo sencillo seria:\r\n\r\n```js\r\nconst contador = () => {   //funcion padre\r\n    let valor = 0;      //estado privado y reusable\r\n\r\n    return ()=>{        //closure o funcion hija\r\n        return valor++;\r\n    }\r\n}\r\n```\r\n\r\nAhora para utilizar nuestro closure:\r\n\r\n```js\r\nconst contar = contador();  //guardamos el closure en la constante contar\r\n\r\nconsole.log(contar())   //0\r\nconsole.log(contar())   //1\r\nconsole.log(contar())   //2\r\n```\r\n\r\nCada vez que llamamos *contar()* accedemos al closure, se retorna su valor actual y luego suma 1 a la variable *valor*.\r\n\r\n### Pruebalo\r\n<p class="codepen" data-height="265" data-theme-id="dark" data-default-tab="js,result" data-user="anb98" data-slug-hash="bGbXgJG" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="Closure">\r\n  <span>See the Pen <a href="https://codepen.io/anb98/pen/bGbXgJG">\r\n  Closure</a> by Abdiel Martinez (<a href="https://codepen.io/anb98">@anb98</a>)\r\n  on <a href="https://codepen.io">CodePen</a>.</span>\r\n</p>\r\n<script async src="https://static.codepen.io/assets/embed/ei.js"><\/script>\r\n\r\n## A la prÃ¡ctica\r\nAunque desde que aprendÃ­ este concepto me pareciÃ³ muy interesante, aun no habia conseguido encontrar un caso practico, finalmente encontre uno podria serle util a mÃ¡s de algun.\r\n\r\nEl problema consiste en realizar consultas a una api, en mi caso realtime de firebase, donde cada resultado quede disponible para que en la siguiente vez que se solicite el mismo dato en lugar de volver a llamar a la *api*, el resultado se devuelva desde el estado local, reduciendo asi el tiempo de respuesta.\r\n\r\nMi solucion:\r\n\r\n```js\r\nimport firebase from \'firebase\';\r\n\r\nconst buscarNodo = (nodo) => {\r\n    const data = {};    //estado reusable\r\n\r\n    return async (valor) => {   //closure asincrono\r\n        if (valor) {\r\n\r\n            const res = data[valor];\r\n            if (res)    \r\n                return res;  //si existe en el estado local se retorna\r\n\r\n            else {\r\n                const snap = await firebase\r\n                .database()\r\n                .ref()\r\n                .child(nodo)\r\n                .child(valor)\r\n                .once(\'value\');\r\n\r\n                if (snap.exists()) {\r\n                    const result = snap.val();\r\n                    result.key   = valor;\r\n                    data[valor]  = result;  //se argega al estado local\r\n\r\n                    return result;  \r\n                }\r\n            }\r\n        }\r\n        \r\n        return false;   //si no existe valor de busqueda \r\n        //o si no hay resultados en el estado local ni en la api\r\n    }\r\n}\r\n\r\nexport default buscarNodo;\r\n```\r\nÂ¿QuÃ© le mejorarias?ðŸ¤”\r\n\r\nPara utilizarlo podria  ser:\r\n```js\r\nconst buscarAlumno   = buscarNodo(\'alumnos\');\r\nconst buscarMateria  = buscarNodo(\'materias\');\r\nconst buscarProfesor = buscarNodo(\'profesores\');\r\n\r\n(async ()=>{  \r\n    // esto es conocido como funcion invocada \r\n    // inmediatamente, en ingles: Immediately invoked function expression (IIFE)\r\n\r\n\r\n    const alumnoEncontrado   = await buscarAlumno( \'idAlumno\');\r\n    const materiaEncontrada  = await buscarMateria( \'idMateria\' );\r\n    const profesorEncontrado = await buscarProfesor( \'idProfesor\' );\r\n\r\n})();\r\n```\r\n\r\nEste es mi caso particular, la llamada a firebase podria ser sustituida por cualquier otra api.\r\n\r\nÂ¿QuÃ© otra idea se te ocurre para utilizar closures?\r\nCompartelo en los comentarios ðŸ˜Š',html:'<h2>QuÃ© es un closure en JS?</h2>\n<p>Empecemos por definir que es un closure (algunos las llaman como clausura o cerradura yo prefiero llamarle closureðŸ˜…). En pocas palabas un closure es:</p>\n<blockquote>\n<p>Un closure es una funciÃ³n que estÃ¡ dentro de otra funcion.</p>\n</blockquote>\n<p>Simple y al grano es una funciÃ³n dentro de otra. Ahora bien Â¿para quÃ© nos puede servir hacer un closure en nuestro codigo? La principal ventaja es que nos permite tener variables en la funcion padre que solo serÃ¡n accesibles desde la funcion interna (hija), ademÃ¡s de poder acceder tambien a los parametros de la funciÃ³n padre. Esto nos permite tener un <strong>estado privado</strong> dentro de nuestra funciÃ³n pero mÃ¡s interesante aun que este sea <em><strong>un estado reusable</strong></em>.</p>\n<p>Un parte importante de los closures es que deben ser retornados por la funcion padre hacia el exterior, a esto se le conoce como funciÃ³n de alto nivel o en inglÃ©s <em>High Order Functions</em>, te invito investigar mÃ¡s sobre ello.</p>\n<p>Regresando a los closures un ejemplo sencillo seria:</p>\n<pre><code class="language-js">const contador = () =&gt; {   //funcion padre\n    let valor = 0;      //estado privado y reusable\n\n    return ()=&gt;{        //closure o funcion hija\n        return valor++;\n    }\n}\n</code></pre>\n<p>Ahora para utilizar nuestro closure:</p>\n<pre><code class="language-js">const contar = contador();  //guardamos el closure en la constante contar\n\nconsole.log(contar())   //0\nconsole.log(contar())   //1\nconsole.log(contar())   //2\n</code></pre>\n<p>Cada vez que llamamos <em>contar()</em> accedemos al closure, se retorna su valor actual y luego suma 1 a la variable <em>valor</em>.</p>\n<h3>Pruebalo</h3>\n<p class="codepen" data-height="265" data-theme-id="dark" data-default-tab="js,result" data-user="anb98" data-slug-hash="bGbXgJG" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="Closure">\n  <span>See the Pen <a href="https://codepen.io/anb98/pen/bGbXgJG">\n  Closure</a> by Abdiel Martinez (<a href="https://codepen.io/anb98">@anb98</a>)\n  on <a href="https://codepen.io">CodePen</a>.</span>\n</p>\n<script async src="https://static.codepen.io/assets/embed/ei.js"><\/script>\n<h2>A la prÃ¡ctica</h2>\n<p>Aunque desde que aprendÃ­ este concepto me pareciÃ³ muy interesante, aun no habia conseguido encontrar un caso practico, finalmente encontre uno podria serle util a mÃ¡s de algun.</p>\n<p>El problema consiste en realizar consultas a una api, en mi caso realtime de firebase, donde cada resultado quede disponible para que en la siguiente vez que se solicite el mismo dato en lugar de volver a llamar a la <em>api</em>, el resultado se devuelva desde el estado local, reduciendo asi el tiempo de respuesta.</p>\n<p>Mi solucion:</p>\n<pre><code class="language-js">import firebase from \'firebase\';\n\nconst buscarNodo = (nodo) =&gt; {\n    const data = {};    //estado reusable\n\n    return async (valor) =&gt; {   //closure asincrono\n        if (valor) {\n\n            const res = data[valor];\n            if (res)    \n                return res;  //si existe en el estado local se retorna\n\n            else {\n                const snap = await firebase\n                .database()\n                .ref()\n                .child(nodo)\n                .child(valor)\n                .once(\'value\');\n\n                if (snap.exists()) {\n                    const result = snap.val();\n                    result.key   = valor;\n                    data[valor]  = result;  //se argega al estado local\n\n                    return result;  \n                }\n            }\n        }\n        \n        return false;   //si no existe valor de busqueda \n        //o si no hay resultados en el estado local ni en la api\n    }\n}\n\nexport default buscarNodo;\n</code></pre>\n<p>Â¿QuÃ© le mejorarias?ðŸ¤”</p>\n<p>Para utilizarlo podria  ser:</p>\n<pre><code class="language-js">const buscarAlumno   = buscarNodo(\'alumnos\');\nconst buscarMateria  = buscarNodo(\'materias\');\nconst buscarProfesor = buscarNodo(\'profesores\');\n\n(async ()=&gt;{  \n    // esto es conocido como funcion invocada \n    // inmediatamente, en ingles: Immediately invoked function expression (IIFE)\n\n\n    const alumnoEncontrado   = await buscarAlumno( \'idAlumno\');\n    const materiaEncontrada  = await buscarMateria( \'idMateria\' );\n    const profesorEncontrado = await buscarProfesor( \'idProfesor\' );\n\n})();\n</code></pre>\n<p>Este es mi caso particular, la llamada a firebase podria ser sustituida por cualquier otra api.</p>\n<p>Â¿QuÃ© otra idea se te ocurre para utilizar closures?\nCompartelo en los comentarios ðŸ˜Š</p>\n',attributes:{_meta:{resourcePath:"C:\\Users\\rocke\\Documents\\blog\\assets\\articulos\\Ejemplo-practico-de-Closure.md"}},vue:{render:"return function render() { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _vm._m(0) }",staticRenderFns:'return [function () { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'div\',{staticClass:"frontmatter-markdown"},[_c(\'h2\',[_vm._v("QuÃ© es un closure en JS?")]),_vm._v(" "),_c(\'p\',[_vm._v("Empecemos por definir que es un closure (algunos las llaman como clausura o cerradura yo prefiero llamarle closureðŸ˜…). En pocas palabas un closure es:")]),_vm._v(" "),_c(\'blockquote\',[_c(\'p\',[_vm._v("Un closure es una funciÃ³n que estÃ¡ dentro de otra funcion.")])]),_vm._v(" "),_c(\'p\',[_vm._v("Simple y al grano es una funciÃ³n dentro de otra. Ahora bien Â¿para quÃ© nos puede servir hacer un closure en nuestro codigo? La principal ventaja es que nos permite tener variables en la funcion padre que solo serÃ¡n accesibles desde la funcion interna (hija), ademÃ¡s de poder acceder tambien a los parametros de la funciÃ³n padre. Esto nos permite tener un "),_c(\'strong\',[_vm._v("estado privado")]),_vm._v(" dentro de nuestra funciÃ³n pero mÃ¡s interesante aun que este sea "),_c(\'em\',[_c(\'strong\',[_vm._v("un estado reusable")])]),_vm._v(".")]),_vm._v(" "),_c(\'p\',[_vm._v("Un parte importante de los closures es que deben ser retornados por la funcion padre hacia el exterior, a esto se le conoce como funciÃ³n de alto nivel o en inglÃ©s "),_c(\'em\',[_vm._v("High Order Functions")]),_vm._v(", te invito investigar mÃ¡s sobre ello.")]),_vm._v(" "),_c(\'p\',[_vm._v("Regresando a los closures un ejemplo sencillo seria:")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true,attrs:{"class":"language-js"}},[_vm._v("const contador = () => {   //funcion padre\\n    let valor = 0;      //estado privado y reusable\\n\\n    return ()=>{        //closure o funcion hija\\n        return valor++;\\n    }\\n}\\n")])]),_vm._v(" "),_c(\'p\',[_vm._v("Ahora para utilizar nuestro closure:")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true,attrs:{"class":"language-js"}},[_vm._v("const contar = contador();  //guardamos el closure en la constante contar\\n\\nconsole.log(contar())   //0\\nconsole.log(contar())   //1\\nconsole.log(contar())   //2\\n")])]),_vm._v(" "),_c(\'p\',[_vm._v("Cada vez que llamamos "),_c(\'em\',[_vm._v("contar()")]),_vm._v(" accedemos al closure, se retorna su valor actual y luego suma 1 a la variable "),_c(\'em\',[_vm._v("valor")]),_vm._v(".")]),_vm._v(" "),_c(\'h3\',[_vm._v("Pruebalo")]),_vm._v(" "),_c(\'p\',{staticClass:"codepen",staticStyle:{"height":"265px","box-sizing":"border-box","display":"flex","align-items":"center","justify-content":"center","border":"2px solid","margin":"1em 0","padding":"1em"},attrs:{"data-height":"265","data-theme-id":"dark","data-default-tab":"js,result","data-user":"anb98","data-slug-hash":"bGbXgJG","data-pen-title":"Closure"}},[_c(\'span\',[_vm._v("See the Pen "),_c(\'a\',{attrs:{"href":"https://codepen.io/anb98/pen/bGbXgJG"}},[_vm._v("\\n  Closure")]),_vm._v(" by Abdiel Martinez ("),_c(\'a\',{attrs:{"href":"https://codepen.io/anb98"}},[_vm._v("@anb98")]),_vm._v(")\\n  on "),_c(\'a\',{attrs:{"href":"https://codepen.io"}},[_vm._v("CodePen")]),_vm._v(".")])]),_vm._v(" "),_c(\'script\',{attrs:{"async":"","src":"https://static.codepen.io/assets/embed/ei.js"}}),_vm._v(" "),_c(\'h2\',[_vm._v("A la prÃ¡ctica")]),_vm._v(" "),_c(\'p\',[_vm._v("Aunque desde que aprendÃ­ este concepto me pareciÃ³ muy interesante, aun no habia conseguido encontrar un caso practico, finalmente encontre uno podria serle util a mÃ¡s de algun.")]),_vm._v(" "),_c(\'p\',[_vm._v("El problema consiste en realizar consultas a una api, en mi caso realtime de firebase, donde cada resultado quede disponible para que en la siguiente vez que se solicite el mismo dato en lugar de volver a llamar a la "),_c(\'em\',[_vm._v("api")]),_vm._v(", el resultado se devuelva desde el estado local, reduciendo asi el tiempo de respuesta.")]),_vm._v(" "),_c(\'p\',[_vm._v("Mi solucion:")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true,attrs:{"class":"language-js"}},[_vm._v("import firebase from \'firebase\';\\n\\nconst buscarNodo = (nodo) => {\\n    const data = {};    //estado reusable\\n\\n    return async (valor) => {   //closure asincrono\\n        if (valor) {\\n\\n            const res = data[valor];\\n            if (res)    \\n                return res;  //si existe en el estado local se retorna\\n\\n            else {\\n                const snap = await firebase\\n                .database()\\n                .ref()\\n                .child(nodo)\\n                .child(valor)\\n                .once(\'value\');\\n\\n                if (snap.exists()) {\\n                    const result = snap.val();\\n                    result.key   = valor;\\n                    data[valor]  = result;  //se argega al estado local\\n\\n                    return result;  \\n                }\\n            }\\n        }\\n        \\n        return false;   //si no existe valor de busqueda \\n        //o si no hay resultados en el estado local ni en la api\\n    }\\n}\\n\\nexport default buscarNodo;\\n")])]),_vm._v(" "),_c(\'p\',[_vm._v("Â¿QuÃ© le mejorarias?ðŸ¤”")]),_vm._v(" "),_c(\'p\',[_vm._v("Para utilizarlo podria  ser:")]),_vm._v(" "),_c(\'pre\',[_c(\'code\',{pre:true,attrs:{"class":"language-js"}},[_vm._v("const buscarAlumno   = buscarNodo(\'alumnos\');\\nconst buscarMateria  = buscarNodo(\'materias\');\\nconst buscarProfesor = buscarNodo(\'profesores\');\\n\\n(async ()=>{  \\n    // esto es conocido como funcion invocada \\n    // inmediatamente, en ingles: Immediately invoked function expression (IIFE)\\n\\n\\n    const alumnoEncontrado   = await buscarAlumno( \'idAlumno\');\\n    const materiaEncontrada  = await buscarMateria( \'idMateria\' );\\n    const profesorEncontrado = await buscarProfesor( \'idProfesor\' );\\n\\n})();\\n")])]),_vm._v(" "),_c(\'p\',[_vm._v("Este es mi caso particular, la llamada a firebase podria ser sustituida por cualquier otra api.")]),_vm._v(" "),_c(\'p\',[_vm._v("Â¿QuÃ© otra idea se te ocurre para utilizar closures?\\nCompartelo en los comentarios ðŸ˜Š")])]) }]',component:{data:function(){return{templateRender:null}},render:function(e){return this.templateRender?this.templateRender():e("div","Rendering")},created:function(){this.templateRender=function(){var e=this.$createElement;this._self._c;return this._m(0)},this.$options.staticRenderFns=[function(){var e=this,n=e.$createElement,r=e._self._c||n;return r("div",{staticClass:"frontmatter-markdown"},[r("h2",[e._v("QuÃ© es un closure en JS?")]),e._v(" "),r("p",[e._v("Empecemos por definir que es un closure (algunos las llaman como clausura o cerradura yo prefiero llamarle closureðŸ˜…). En pocas palabas un closure es:")]),e._v(" "),r("blockquote",[r("p",[e._v("Un closure es una funciÃ³n que estÃ¡ dentro de otra funcion.")])]),e._v(" "),r("p",[e._v("Simple y al grano es una funciÃ³n dentro de otra. Ahora bien Â¿para quÃ© nos puede servir hacer un closure en nuestro codigo? La principal ventaja es que nos permite tener variables en la funcion padre que solo serÃ¡n accesibles desde la funcion interna (hija), ademÃ¡s de poder acceder tambien a los parametros de la funciÃ³n padre. Esto nos permite tener un "),r("strong",[e._v("estado privado")]),e._v(" dentro de nuestra funciÃ³n pero mÃ¡s interesante aun que este sea "),r("em",[r("strong",[e._v("un estado reusable")])]),e._v(".")]),e._v(" "),r("p",[e._v("Un parte importante de los closures es que deben ser retornados por la funcion padre hacia el exterior, a esto se le conoce como funciÃ³n de alto nivel o en inglÃ©s "),r("em",[e._v("High Order Functions")]),e._v(", te invito investigar mÃ¡s sobre ello.")]),e._v(" "),r("p",[e._v("Regresando a los closures un ejemplo sencillo seria:")]),e._v(" "),r("pre",[r("code",{pre:!0,attrs:{class:"language-js"}},[e._v("const contador = () => {   //funcion padre\n    let valor = 0;      //estado privado y reusable\n\n    return ()=>{        //closure o funcion hija\n        return valor++;\n    }\n}\n")])]),e._v(" "),r("p",[e._v("Ahora para utilizar nuestro closure:")]),e._v(" "),r("pre",[r("code",{pre:!0,attrs:{class:"language-js"}},[e._v("const contar = contador();  //guardamos el closure en la constante contar\n\nconsole.log(contar())   //0\nconsole.log(contar())   //1\nconsole.log(contar())   //2\n")])]),e._v(" "),r("p",[e._v("Cada vez que llamamos "),r("em",[e._v("contar()")]),e._v(" accedemos al closure, se retorna su valor actual y luego suma 1 a la variable "),r("em",[e._v("valor")]),e._v(".")]),e._v(" "),r("h3",[e._v("Pruebalo")]),e._v(" "),r("p",{staticClass:"codepen",staticStyle:{height:"265px","box-sizing":"border-box",display:"flex","align-items":"center","justify-content":"center",border:"2px solid",margin:"1em 0",padding:"1em"},attrs:{"data-height":"265","data-theme-id":"dark","data-default-tab":"js,result","data-user":"anb98","data-slug-hash":"bGbXgJG","data-pen-title":"Closure"}},[r("span",[e._v("See the Pen "),r("a",{attrs:{href:"https://codepen.io/anb98/pen/bGbXgJG"}},[e._v("\n  Closure")]),e._v(" by Abdiel Martinez ("),r("a",{attrs:{href:"https://codepen.io/anb98"}},[e._v("@anb98")]),e._v(")\n  on "),r("a",{attrs:{href:"https://codepen.io"}},[e._v("CodePen")]),e._v(".")])]),e._v(" "),r("script",{attrs:{async:"",src:"https://static.codepen.io/assets/embed/ei.js"}}),e._v(" "),r("h2",[e._v("A la prÃ¡ctica")]),e._v(" "),r("p",[e._v("Aunque desde que aprendÃ­ este concepto me pareciÃ³ muy interesante, aun no habia conseguido encontrar un caso practico, finalmente encontre uno podria serle util a mÃ¡s de algun.")]),e._v(" "),r("p",[e._v("El problema consiste en realizar consultas a una api, en mi caso realtime de firebase, donde cada resultado quede disponible para que en la siguiente vez que se solicite el mismo dato en lugar de volver a llamar a la "),r("em",[e._v("api")]),e._v(", el resultado se devuelva desde el estado local, reduciendo asi el tiempo de respuesta.")]),e._v(" "),r("p",[e._v("Mi solucion:")]),e._v(" "),r("pre",[r("code",{pre:!0,attrs:{class:"language-js"}},[e._v("import firebase from 'firebase';\n\nconst buscarNodo = (nodo) => {\n    const data = {};    //estado reusable\n\n    return async (valor) => {   //closure asincrono\n        if (valor) {\n\n            const res = data[valor];\n            if (res)    \n                return res;  //si existe en el estado local se retorna\n\n            else {\n                const snap = await firebase\n                .database()\n                .ref()\n                .child(nodo)\n                .child(valor)\n                .once('value');\n\n                if (snap.exists()) {\n                    const result = snap.val();\n                    result.key   = valor;\n                    data[valor]  = result;  //se argega al estado local\n\n                    return result;  \n                }\n            }\n        }\n        \n        return false;   //si no existe valor de busqueda \n        //o si no hay resultados en el estado local ni en la api\n    }\n}\n\nexport default buscarNodo;\n")])]),e._v(" "),r("p",[e._v("Â¿QuÃ© le mejorarias?ðŸ¤”")]),e._v(" "),r("p",[e._v("Para utilizarlo podria  ser:")]),e._v(" "),r("pre",[r("code",{pre:!0,attrs:{class:"language-js"}},[e._v("const buscarAlumno   = buscarNodo('alumnos');\nconst buscarMateria  = buscarNodo('materias');\nconst buscarProfesor = buscarNodo('profesores');\n\n(async ()=>{  \n    // esto es conocido como funcion invocada \n    // inmediatamente, en ingles: Immediately invoked function expression (IIFE)\n\n\n    const alumnoEncontrado   = await buscarAlumno( 'idAlumno');\n    const materiaEncontrada  = await buscarMateria( 'idMateria' );\n    const profesorEncontrado = await buscarProfesor( 'idProfesor' );\n\n})();\n")])]),e._v(" "),r("p",[e._v("Este es mi caso particular, la llamada a firebase podria ser sustituida por cualquier otra api.")]),e._v(" "),r("p",[e._v("Â¿QuÃ© otra idea se te ocurre para utilizar closures?\nCompartelo en los comentarios ðŸ˜Š")])])}]}}}}}}]);